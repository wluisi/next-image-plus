import * as React from "react";

import { getImageProps as getNextImageProps } from "next/image";
import {
  PreloadImageLink,
  ImageAttributes as PreloadImageAttributes,
} from "./preload";

/*
 *
 */
function getValidReactChildren(children: React.ReactNode) {
  return React.Children.toArray(children).filter((child) =>
    React.isValidElement(child)
  ) as React.ReactElement[];
}

export type SourceProps = {
  srcSet: string;
  src: string;
  media: string;
  sizes?: string;
  width: number | `${number}`;
  height: number | `${number}`;
};

/**
 * Source component that renders a `<source>` element.
 */
export function Source(props: Omit<SourceProps, "srcSet">) {
  return <source {...props} />;
}

export type ImageProps = React.ImgHTMLAttributes<HTMLImageElement> & {
  /** The media query to be used for the fallback image, if preload is true. */
  media?: string;
};

export function Image({ src, width, height, alt, className }: ImageProps) {
  return (
    // eslint-disable-next-line @next/next/no-img-element
    <img
      src={src}
      width={width}
      height={height}
      alt={alt}
      className={className}
      // onLoad={(event) =>
      //   console.log("Loaded src:", event.currentTarget.currentSrc)
      // }
    />
  );
}

export type PictureProps = React.ComponentPropsWithRef<"picture"> & {
  preload?: boolean;
  /** The media query to be used for the fallback image, if preload is true. */
  fallbackMedia?: string;
  children: React.ReactElement<SourceProps>[] | React.ReactElement<ImageProps>;
};

export function Picture({
  preload = false,
  fallbackMedia,
  children,
}: PictureProps) {
  const preloadData: PreloadImageAttributes[] = [];

  const childrenValidated = getValidReactChildren(children);

  // Find the Image component passed as a child.
  const imgElement = childrenValidated.find((child) => child.type === Image);
  if (!imgElement) {
    throw new Error("Image component not found in children");
  }

  const imgChildProps: ImageProps = imgElement.props;
  const { props: imageProps } = getNextImageProps({
    src: imgChildProps.src,
    alt: imgChildProps.alt,
    width: imgChildProps.width as number,
    height: imgChildProps.height as number,
  });

  preloadData.push({
    media: fallbackMedia,
    fetchPriority: preload ? "high" : "auto",
    ...imageProps,
  });

  const imgClone: React.ReactElement<ImageProps> = React.cloneElement(
    imgElement,
    {
      ...imageProps,
    }
  );

  const alt = imgClone.props.alt;

  const sourceClones = childrenValidated.map(
    (child: React.ReactElement<SourceProps>) => {
      if (child.type === Source) {
        const { props: sourceProps } = getNextImageProps({
          src: child.props.src,
          alt: alt,
          sizes: child.props.sizes,
          width: child.props.width,
          height: child.props.height,
        });

        preloadData.push({
          media: child.props.media,
          fetchPriority: preload ? "high" : "auto",
          ...sourceProps,
        });

        return React.cloneElement(child, {
          // Effectively remove the src prop, since we don't want it on the final <source> element.
          src: undefined,
          // Add srcSet generated by next image api.
          srcSet: sourceProps.srcSet,
          media: child.props.media,
          sizes: sourceProps.sizes,
          width: sourceProps.width,
          height: sourceProps.height,
        });
      }
    }
  );

  return (
    <>
      <picture>
        {sourceClones}
        {imgClone}
      </picture>
      {preload ? <PreloadImageLink data={preloadData} /> : null}
    </>
  );
}
